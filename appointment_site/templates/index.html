<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Appointment Table</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <style>
        .location-btn {
            margin: 0 5px 5px 0;
        }
        th {
            cursor: pointer;
            user-select: none;
        }
    </style>
</head>
<body>
<div class="container mt-4">
    <h2 class="mb-4">Appointment Dates</h2>
    <p><strong>Last Updated:</strong> {{ last_updated }} ({{ time_since }})</p>
    
    <div class="mb-3">
        <label for="branchSearch" class="form-label">Search and Add Branch:</label>
        <input type="text" id="branchSearch" class="form-control" placeholder="Type a branch name..." autocomplete="off" />
        <ul id="branchResults" class="list-group mt-2"></ul>
    </div>

    <div id="locationButtons" class="mb-3"></div>

    <div class="mb-3">
        <button id="toggleEarliestBtn" class="btn btn-outline-primary">Show Earliest Date per Branch</button>
        <button id="getLocationBtn" class="btn btn-primary ms-2">üìç Find My Location</button>
    </div>

    <div class="table-responsive">
        <table class="table table-striped table-bordered" id="appointmentsTable">
            <thead>
                <tr>
                    <th data-col="branch" data-type="string">Branch Name <span></span></th>
                    <th data-col="address" data-type="string">Address <span></span></th>
                    <th data-col="date" data-type="date">Date <span></span></th>
                    <th data-col="distance" data-type="number">Distance (km) <span></span></th>
                </tr>
            </thead>
            <tbody>
                {% for entry in entries %}
                <tr data-branch-id="{{ entry.branch_id }}">
                    <td>{{ entry.branch_name }}</td>
                    <td>{{ entry.address }}</td>
                    <td>{{ entry.date }}</td>
                    <td>{% if entry.distance is not none %}{{ entry.distance }}{% else %}-{% endif %}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</div>

<script>
    // Grab URL params for lat/lon (used to recalc distance and sort)
    let userLat = parseFloat(new URLSearchParams(window.location.search).get("lat"));
    let userLon = parseFloat(new URLSearchParams(window.location.search).get("lon"));

    const table = document.getElementById("appointmentsTable");
    const tbody = table.tBodies[0];
    const allRows = [...tbody.rows];
    const searchInput = document.getElementById("branchSearch");
    const resultsList = document.getElementById("branchResults");
    const locationButtons = document.getElementById("locationButtons");
    const earliestBtn = document.getElementById("toggleEarliestBtn");
    const getLocationBtn = document.getElementById("getLocationBtn");

    let activeBranchIds = [];
    let showEarliestOnly = false;

    // Sorting state: which col, and ascending or descending
    let sortColIndex = null;
    let sortAscending = true;

    // Build branch name list from rows for search/autocomplete
    const branchNames = [...new Set(allRows.map(row => {
        const id = row.getAttribute("data-branch-id");
        const name = row.cells[0].textContent.trim();
        return `${id}|${name}`;
    }))];

    // Function: Calculate distance between two lat/lon points (km)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth radius in km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return +(R * c).toFixed(2);
    }

    // Update visibility of rows based on active filters and toggle earliest only
    function updateTableVisibility() {
        // Group rows by branch id
        const groupedByBranch = {};
        allRows.forEach(row => {
            const branchId = row.getAttribute("data-branch-id");
            if (!groupedByBranch[branchId]) groupedByBranch[branchId] = [];
            groupedByBranch[branchId].push(row);
        });

        allRows.forEach(row => row.style.display = "none");

        for (const [branchId, rows] of Object.entries(groupedByBranch)) {
            if (activeBranchIds.length === 0 || activeBranchIds.includes(branchId)) {
                if (showEarliestOnly) {
                    // Find earliest date in group
                    const sortedRows = rows.slice().sort((a,b) => {
                        return new Date(a.cells[2].textContent.trim()) - new Date(b.cells[2].textContent.trim());
                    });
                    sortedRows[0].style.display = "";
                } else {
                    rows.forEach(r => r.style.display = "");
                }
            }
        }
    }

    // Add branch filter button
    function addLocationFilter(id, name) {
        if (activeBranchIds.includes(id)) return;
        activeBranchIds.push(id);
        updateTableVisibility();

        const btn = document.createElement("button");
        btn.className = "btn btn-secondary btn-sm location-btn";
        btn.textContent = name + " ‚úï";
        btn.title = "Remove filter";
        btn.onclick = () => {
            activeBranchIds = activeBranchIds.filter(bid => bid !== id);
            locationButtons.removeChild(btn);
            updateTableVisibility();
        };
        locationButtons.appendChild(btn);
    }

    // Branch search autocomplete
    searchInput.addEventListener("input", () => {
        const val = searchInput.value.toLowerCase().trim();
        resultsList.innerHTML = "";
        if (!val) return;

        const matches = branchNames.filter(item => item.toLowerCase().includes(val)).slice(0, 5);
        matches.forEach(match => {
            const [id, name] = match.split("|");
            const li = document.createElement("li");
            li.className = "list-group-item list-group-item-action";
            li.textContent = name;
            li.onclick = () => {
                addLocationFilter(id, name);
                searchInput.value = "";
                resultsList.innerHTML = "";
            };
            resultsList.appendChild(li);
        });
    });

    // Sorting function on table headers
    function sortTable(colIndex, type) {
        const rowsArray = Array.from(tbody.rows).filter(row => row.style.display !== "none");
        const getCellValue = (row) => row.cells[colIndex].textContent.trim();

        rowsArray.sort((a, b) => {
            let valA = getCellValue(a);
            let valB = getCellValue(b);

            if (type === "number") {
                valA = parseFloat(valA) || 0;
                valB = parseFloat(valB) || 0;
            } else if (type === "date") {
                valA = new Date(valA);
                valB = new Date(valB);
            } else {
                valA = valA.toLowerCase();
                valB = valB.toLowerCase();
            }

            if (valA < valB) return sortAscending ? -1 : 1;
            if (valA > valB) return sortAscending ? 1 : -1;
            return 0;
        });

        // Re-append rows in sorted order
        rowsArray.forEach(row => tbody.appendChild(row));

        // Toggle sort direction for next click
        sortAscending = !sortAscending;
        sortColIndex = colIndex;

        // Update sort icons
        updateSortIcons();
    }

    // Update sorting icons on headers
    function updateSortIcons() {
        const headers = table.tHead.rows[0].cells;
        for (let i = 0; i < headers.length; i++) {
            const span = headers[i].querySelector("span");
            if (i === sortColIndex) {
                span.textContent = sortAscending ? "‚ñ≤" : "‚ñº";
            } else {
                span.textContent = "";
            }
        }
    }

    // Attach sorting events to headers
    Array.from(table.tHead.rows[0].cells).forEach((th, i) => {
        const type = th.getAttribute("data-type");
        th.addEventListener("click", () => sortTable(i, type));
    });

    // Toggle earliest date button
    earliestBtn.addEventListener("click", () => {
        showEarliestOnly = !showEarliestOnly;
        earliestBtn.textContent = showEarliestOnly ? "Show All Dates" : "Show Earliest Date per Branch";
        updateTableVisibility();
    });

    // GPS location button: get user's location and reload page with lat/lon params
    getLocationBtn.addEventListener("click", () => {
        if (!navigator.geolocation) {
            alert("Geolocation is not supported by your browser.");
            return;
        }
        getLocationBtn.disabled = true;
        getLocationBtn.textContent = "Locating...";

        navigator.geolocation.getCurrentPosition(position => {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            // Update URL params and reload
            const url = new URL(window.location);
            url.searchParams.set("lat", lat);
            url.searchParams.set("lon", lon);
            window.location.href = url.toString();
        }, () => {
            alert("Unable to retrieve your location.");
            getLocationBtn.disabled = false;
            getLocationBtn.textContent = "üìç Find My Location";
        });
    });

    // If lat/lon present, recalc distances for all rows, then sort by distance asc by default
    if (!isNaN(userLat) && !isNaN(userLon)) {
        allRows.forEach(row => {
            const latText = row.cells[3].textContent.trim();
            if (latText === "-" || latText === "") return; // No distance to recalc if no lat/lon data

            // The original distance was calculated server-side, but if you want to recalc here:
            // Actually we only have the distance number; to recalc we would need lat/lon of branch.
            // So this requires the lat/lon of each branch in JS or another approach.
            // For simplicity, keep server-side distance.

            // Alternatively, we could sort rows by existing distance values:
        });

        // Sort by distance asc initially
        sortColIndex = 3; // distance column
        sortAscending = true;
        sortTable(sortColIndex, "number");
    }

    // Initial table visibility update on page load
    updateTableVisibility();
</script>
</body>
</html>
