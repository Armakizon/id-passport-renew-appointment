<div class="table-responsive">
    <table class="table table-striped table-bordered" id="appointmentsTable">
        <thead>
            <tr>
                <th class="sortable" data-label="Branch Name">Branch Name</th>
                <th class="sortable" data-label="Address">Address</th>
                <th class="sortable" data-label="Date">Date</th>
                <th class="sortable" data-label="Distance (km)">Distance (km)</th>
            </tr>
        </thead>
        <tbody>
            {% for entry in entries %}
            <tr data-branch-id="{{ entry.branch_id }}" data-lat="{{ entry.latitude }}" data-lon="{{ entry.longitude }}">
                <td>{{ entry.branch_name }}</td>
                <td>{{ entry.address }}</td>
                <td>{{ entry.date }}</td>
                <td>{% if entry.distance %}{{ entry.distance }}{% else %}-{% endif %}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<script>
document.querySelectorAll("#appointmentsTable th.sortable").forEach(th => {
    th.dataset.label = th.textContent.trim();

    th.addEventListener("click", () => {
        const column = th.cellIndex;
        const table = document.getElementById("appointmentsTable");
        const rows = Array.from(table.querySelector("tbody").rows);
        const isAscending = th.dataset.sorted !== "asc";
        
        // Clear sort indicators on all headers
        document.querySelectorAll("#appointmentsTable th.sortable").forEach(header => {
            header.innerHTML = header.dataset.label;
            delete header.dataset.sorted;
        });

        th.dataset.sorted = isAscending ? "asc" : "desc";
        th.innerHTML = `${th.dataset.label} <span class="sort-indicator">${isAscending ? "↑" : "↓"}</span>`;

        const sorted = rows.sort((a, b) => {
            let valA = a.cells[column].textContent.trim();
            let valB = b.cells[column].textContent.trim();

            // Attempt numeric sort if both values are numbers
            const numA = parseFloat(valA.replace(",", ""));
            const numB = parseFloat(valB.replace(",", ""));
            const isDate = column === 2;

            if (isDate) {
                // Attempt to parse dates
                const dateA = new Date(valA);
                const dateB = new Date(valB);
                if (!isNaN(dateA) && !isNaN(dateB)) {
                    return isAscending ? dateA - dateB : dateB - dateA;
                }
            } else if (!isNaN(numA) && !isNaN(numB)) {
                return isAscending ? numA - numB : numB - numA;
            }

            return isAscending ? valA.localeCompare(valB) : valB.localeCompare(valA);
        });

        const tbody = table.querySelector("tbody");
        tbody.innerHTML = "";
        sorted.forEach(row => tbody.appendChild(row));
    });
});
</script>
